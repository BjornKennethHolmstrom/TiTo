<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üïö TiTo</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Left Column: Title, Timer, and Clear Database -->
        <div class="column">
            <h1>üïö TiTo Time Tracker</h1>
            <div class="section timer-section">
                <h3>Timer</h3>
                <div class="button-container">
                    <button id="playPauseButton">‚ñ∂Ô∏è</button>
                    <button id="stopButton">‚èπÔ∏è</button>
                </div>
                <div id="timeDisplay">00:00:00</div>
            </div>
            <button id="clearDatabaseButton" class="red-button">Clear Database</button>
        </div>

        <!-- Middle Column: Project Management -->
        <div class="column">
            <div class="section">
                <input type="text" id="newProjectName" placeholder="Enter new project name">
                <button id="addProjectButton">Add Project</button>
            </div>

            <div class="section">
                <h2>Projects</h2>
                <ul id="projectList">
                    <!-- Project list items will be inserted here -->
                </ul>
            </div>
        </div>

        <!-- Right Column: Time Entries -->
        <div class="column">
            <div class="section time-entries-section">
                <h2>Time Entries</h2>
                <button id="addManualEntryButton">Add Manual Entry</button>
                <ul id="timeEntryList">
                    <!-- Time entry list items will be inserted here -->
                </ul>
            </div>
        </div>
    </div>
    <script>
    // Global Variables
    let db;
    let dbReady = new Promise((resolve, reject) => {
        let request = indexedDB.open('TimeTrackerDB', 1);

        request.onerror = function(event) {
            reject('Error opening IndexedDB:', event);
        };

        request.onsuccess = function(event) {
            db = event.target.result;
            resolve();
        };

        request.onupgradeneeded = function(event) {
            db = event.target.result;
            let projectStore = db.createObjectStore('projects', { keyPath: 'id', autoIncrement: true });
            projectStore.createIndex('name', 'name', { unique: true });

            let timeEntryStore = db.createObjectStore('timeEntries', { keyPath: 'id', autoIncrement: true });
            timeEntryStore.createIndex('projectId', 'projectId', { unique: false });
            timeEntryStore.createIndex('description', 'description', { unique: false });
        };
    });

    let currentProject = null;
    let startTime;
    let elapsedTime = 0;
    let isPaused = false;
    let isRunning = false;
    let isTimerRunning = false;
    let timerInterval;

    document.addEventListener('DOMContentLoaded', function() {
        const addProjectButton = document.getElementById('addProjectButton');
        const playPauseButton = document.getElementById('playPauseButton');
        const stopButton = document.getElementById('stopButton');
        const addManualEntryButton = document.getElementById('addManualEntryButton');
        if (addManualEntryButton) {
            addManualEntryButton.addEventListener('click', addManualEntry);
        }

        if (addProjectButton) {
            addProjectButton.addEventListener('click', addProject);
        }
        if (playPauseButton) {
            playPauseButton.addEventListener('click', togglePlayPause);
        }
        if (stopButton) {
            stopButton.addEventListener('click', stopTimer);
        }
        document.getElementById('clearDatabaseButton').addEventListener('click', clearDatabase);
        document.getElementById('newProjectName').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent the default form submission if applicable
                addProject(); // Call the addProject function
            }
        });
        loadProjects();
        loadTimeEntries();
        populateDropdowns();
    });

    function clearDatabase() {
        if (confirm('Are you sure you want to clear all data? This action cannot be undone.')) {
            dbReady.then(() => {
                let transaction = db.transaction(['projects', 'timeEntries'], 'readwrite');
                let projectStore = transaction.objectStore('projects');
                projectStore.clear().onsuccess = function() {
                    console.log('Projects cleared');
                    loadProjects(); // Update UI after clearing
                };
                let timeEntryStore = transaction.objectStore('timeEntries');
                timeEntryStore.clear().onsuccess = function() {
                    console.log('Time entries cleared');
                    location.reload();
                };

                transaction.onerror = function(event) {
                    console.error('Error clearing database:', event.target.errorCode);
                };
            }).catch(error => {
                console.error('Error clearing database:', error);
            });
        }
    }

    function populateDropdowns() {
        // Populate dropdowns with options (year, month, day, etc.)
    }

    function addProject() {
        dbReady.then(() => {
            const projectName = document.getElementById('newProjectName').value;
            if (projectName) {
                let transaction = db.transaction(['projects'], 'readwrite');
                let store = transaction.objectStore('projects');
                
                // Get the current highest order
                let countRequest = store.count();
                countRequest.onsuccess = function() {
                    let newOrder = countRequest.result; // This will be the new highest order
                    let request = store.add({ name: projectName, order: newOrder });

                    request.onsuccess = function() {
                        document.getElementById('newProjectName').value = '';
                        loadProjects();
                    };

                    request.onerror = function(event) {
                        console.error('Error adding project:', event);
                    };
                };
            } else {
                console.error('Project name is empty');
            }
        }).catch(error => {
            console.error('Database error:', error);
        });
    }
    function loadProjects() {
        dbReady.then(() => {
            let transaction = db.transaction(['projects'], 'readonly');
            let store = transaction.objectStore('projects');
            let request = store.getAll();

            request.onsuccess = function(event) {
                const projects = event.target.result;
                console.log('Loaded projects:', projects);  // Add this line
                renderProjectList(projects);
                if (projects.length === 1) {
                    setCurrentProject(projects[0]);
                }
            };

            request.onerror = function(event) {  // Add this error handler
                console.error('Error loading projects:', event);
            };
        }).catch(error => {
            console.error('Database error in loadProjects:', error);
        });
    }

    function renderProjectList(projects) {
        console.log('Rendering projects:', projects);
        const projectListElement = document.getElementById('projectList');
        if (!projectListElement) {
            console.error('Project list element not found');
            return;
        }
        projectListElement.innerHTML = '';

        projects.forEach((project, index) => {
            const listItem = document.createElement('li');
            listItem.dataset.projectId = project.id;
            listItem.draggable = true;

            const projectName = document.createElement('span');
            projectName.textContent = project.name;
            projectName.className = 'project-name';
            projectName.addEventListener('click', function() {
                setCurrentProject(project);
            });

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'üóëÔ∏è';
            deleteButton.className = 'remove-project-button';
            deleteButton.title = 'Delete project';
            deleteButton.addEventListener('click', function(event) {
                event.stopPropagation();
                deleteProject(project.id);
            });

            listItem.appendChild(projectName);
            listItem.appendChild(deleteButton);
            projectListElement.appendChild(listItem);

            // Add drag and drop event listeners
            listItem.addEventListener('dragstart', handleDragStart);
            listItem.addEventListener('dragover', handleDragOver);
            listItem.addEventListener('drop', handleDrop);
            listItem.addEventListener('dragend', handleDragEnd);
        });

        // Highlight the current project if one is selected
        if (currentProject) {
            const currentProjectItem = projectListElement.querySelector(`[data-project-id="${currentProject.id}"]`);
            if (currentProjectItem) {
                currentProjectItem.classList.add('selected');
            }
        }
    }

    let dragSrcEl = null;

    function handleDragStart(e) {
        this.style.opacity = '0.4';
        dragSrcEl = this;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
    }

    function handleDragOver(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function handleDrop(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }

        if (dragSrcEl != this) {
            // Get the project IDs
            const draggedProjectId = dragSrcEl.dataset.projectId;
            const targetProjectId = this.dataset.projectId;

            // Swap the HTML contents
            const tempHTML = dragSrcEl.innerHTML;
            dragSrcEl.innerHTML = this.innerHTML;
            this.innerHTML = tempHTML;

            // Swap the data-project-id attributes
            dragSrcEl.dataset.projectId = targetProjectId;
            this.dataset.projectId = draggedProjectId;

            // If the current project was involved in the swap, update it
            if (currentProject && (currentProject.id == draggedProjectId || currentProject.id == targetProjectId)) {
                const updatedProjectElement = document.querySelector(`#projectList li[data-project-id="${currentProject.id}"]`);
                if (updatedProjectElement) {
                    setCurrentProject({
                        id: currentProject.id,
                        name: updatedProjectElement.querySelector('.project-name').textContent
                    });
                }
            }

            // Reattach event listeners
            [dragSrcEl, this].forEach(item => {
                const projectName = item.querySelector('.project-name');
                const deleteButton = item.querySelector('.remove-project-button');
            
                // Remove existing listeners to prevent duplicates
                projectName.replaceWith(projectName.cloneNode(true));
                deleteButton.replaceWith(deleteButton.cloneNode(true));
            
                // Add new listeners
                item.querySelector('.project-name').addEventListener('click', function() {
                    setCurrentProject({
                        id: parseInt(item.dataset.projectId),
                        name: this.textContent
                    });
                });
            
                item.querySelector('.remove-project-button').addEventListener('click', function(event) {
                    event.stopPropagation();
                    deleteProject(parseInt(item.dataset.projectId));
                });
            });
        
            updateProjectOrder();
        }
    
        return false;
    }

    function handleDragEnd(e) {
        this.style.opacity = '1';
        document.querySelectorAll('#projectList li').forEach(function (item) {
            item.classList.remove('over');
        });
    }
    
    function updateProjectOrder() {
        const projectItems = document.querySelectorAll('#projectList li');
        const newOrder = Array.from(projectItems).map(item => item.dataset.projectId);
        
        console.log('New project order:', newOrder);
        
        dbReady.then(() => {
            let transaction = db.transaction(['projects'], 'readwrite');
            let store = transaction.objectStore('projects');

            // First, retrieve all projects
            store.getAll().onsuccess = function(event) {
                let projects = event.target.result;
                
                // Sort projects based on the new order
                projects.sort((a, b) => {
                    return newOrder.indexOf(a.id.toString()) - newOrder.indexOf(b.id.toString());
                });

                // Update each project with its new order
                projects.forEach((project, index) => {
                    project.order = index;
                    store.put(project);
                });
            };

            transaction.oncomplete = function() {
                console.log('Project order updated in database');
            };

            transaction.onerror = function(event) {
                console.error('Error updating project order:', event.target.error);
            };
        }).catch(error => {
            console.error('Database error:', error);
        });
    }
    

    function deleteProject(projectId) {
        if (confirm('Are you sure you want to delete this project? All associated time entries will also be deleted.')) {
            dbReady.then(() => {
                let transaction = db.transaction(['projects', 'timeEntries'], 'readwrite');
                let projectStore = transaction.objectStore('projects');
                let timeEntryStore = transaction.objectStore('timeEntries');

                // Delete the project
                projectStore.delete(projectId).onsuccess = function() {
                    console.log('Project deleted');
                };

                // Delete all time entries for this project
                let index = timeEntryStore.index('projectId');
                let request = index.openCursor(IDBKeyRange.only(projectId));

                request.onsuccess = function(event) {
                    let cursor = event.target.result;
                    if (cursor) {
                        timeEntryStore.delete(cursor.primaryKey);
                        cursor.continue();
                    }
                };

                transaction.oncomplete = function() {
                    console.log('Project and associated time entries deleted');
                    if (currentProject && currentProject.id === projectId) {
                        currentProject = null;
                        resetTimer();
                    }
                    loadProjects();
                    if (currentProject) {
                        loadTimeEntries();
                    } else {
                        clearTimeEntryList();
                    }
                };
            }).catch(error => {
                console.error('Database error:', error);
            });
        }
    }
    
    function clearTimeEntryList() {
        const timeEntryListElement = document.getElementById('timeEntryList');
        if (timeEntryListElement) {
            timeEntryListElement.innerHTML = '';
        }
    }
    
    // We also need to modify the loadProjects function to respect the order
    function loadProjects() {
        dbReady.then(() => {
            let transaction = db.transaction(['projects'], 'readonly');
            let store = transaction.objectStore('projects');
            let request = store.getAll();

            request.onsuccess = function(event) {
                let projects = event.target.result;
                // Sort projects by their order before rendering
                projects.sort((a, b) => (a.order || 0) - (b.order || 0));
                console.log('Loaded projects:', projects);
                renderProjectList(projects);
                if (projects.length === 0) {
                    currentProject = null;
                    clearTimeEntryList();
                } else if (!currentProject || !projects.some(p => p.id === currentProject.id)) {
                    setCurrentProject(projects[0]);
                }
            };

            request.onerror = function(event) {
                console.error('Error loading projects:', event);
            };
        }).catch(error => {
            console.error('Database error in loadProjects:', error);
        });
    }

    function setCurrentProject(project) {
        currentProject = project;

        // Remove 'selected' class from all project items
        const projectItems = document.querySelectorAll('#projectList li');
        projectItems.forEach(item => item.classList.remove('selected'));

        // Add 'selected' class to the clicked project item
        const selectedItem = document.querySelector(`#projectList li[data-project-id="${project.id}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');
        }

        console.log('Current project set to:', project);
        loadTimeEntries();
    }



    function togglePlayPause() {
        if (!isTimerRunning) {
            startTimer();
        } else if (isPaused) {
            resumeTimer();
        } else {
            pauseTimer();
        }
    }

    function startTimer() {
        if (!currentProject) {
            alert('Please select a project first.');
            return;
        }
        isTimerRunning = true;
        isPaused = false;
        startTime = Date.now();
        console.log('Timer started at:', new Date(startTime));
        timerInterval = setInterval(updateTimeDisplay, 1000);
        updatePlayPauseButton();
    }

    function pauseTimer() {
        isPaused = true;
        clearInterval(timerInterval);
        console.log('Timer paused at:', new Date());
        updatePlayPauseButton();
    }

    function resumeTimer() {
        isPaused = false;
        startTime = Date.now() - elapsedTime;
        timerInterval = setInterval(updateTimeDisplay, 1000);
        console.log('Timer resumed at:', new Date());
        updatePlayPauseButton();
    }

    function stopTimer() {
        if (isTimerRunning) {
            clearInterval(timerInterval);
            isTimerRunning = false;
            isPaused = false;
            
            let stopTime = Date.now();
            
            console.log('Timer stopped at:', new Date(stopTime));
            console.log('Elapsed time (ms):', elapsedTime);
            
            saveTimeEntry(startTime, stopTime);
            resetTimer();
            loadTimeEntries();
            // Scroll to bottom after stopping the timer
            scrollToBottom(document.getElementById('timeEntryList'));
        } else {
            alert("No timer is currently running.");
        }
    }

    function updatePlayPauseButton() {
        const playPauseButton = document.getElementById('playPauseButton');
        if (isTimerRunning && !isPaused) {
            playPauseButton.textContent = '‚è∏Ô∏è';
            playPauseButton.title = 'Pause';
        } else {
            playPauseButton.textContent = '‚ñ∂Ô∏è';
            playPauseButton.title = 'Play';
        }
    }

    function updateTimeDisplay() {
        if (!isPaused && isTimerRunning) {
            const currentTime = Date.now();
            elapsedTime = currentTime - startTime;
            const formattedTime = formatDuration(elapsedTime);
            document.getElementById('timeDisplay').textContent = formattedTime;
        }
    }

    function resetTimer() {
        elapsedTime = 0;
        startTime = null;
        isTimerRunning = false;
        isPaused = false;
        clearInterval(timerInterval);
        document.getElementById('timeDisplay').textContent = '00:00:00';
        updatePlayPauseButton();
    }

    function formatDuration(duration) {
        const hours = Math.floor(duration / 3600000);
        const minutes = Math.floor((duration % 3600000) / 60000);
        const seconds = Math.floor((duration % 60000) / 1000);
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function loadTimeEntries() {
        if (!currentProject) {
            console.log('No current project, not loading time entries');
            return;
        }

        console.log('Loading time entries for project:', currentProject);

        dbReady.then(() => {
            let transaction = db.transaction(['timeEntries'], 'readonly');
            let store = transaction.objectStore('timeEntries');
            let index = store.index('projectId');
            let request = index.getAll(currentProject.id);

            request.onsuccess = function(event) {
                const timeEntries = event.target.result;
                console.log('Loaded time entries:', timeEntries);
                renderTimeEntryList(timeEntries);
            };

            request.onerror = function(event) {
                console.error('Error loading time entries:', event);
            };
        }).catch(error => {
            console.error('Database error in loadTimeEntries:', error);
        });
    }

    function renderTimeEntryList(timeEntries) {
        const timeEntryListElement = document.getElementById('timeEntryList');
        timeEntryListElement.innerHTML = '';

        timeEntries.forEach(entry => {
            const listItem = document.createElement('li');
        
            // Create dropdowns for start time
            const startDropdowns = createDateTimeDropdowns(new Date(entry.start), 'start');
        
            // Create dropdowns for end time
            const endDropdowns = createDateTimeDropdowns(new Date(entry.end), 'end');
        
            // Create span for total time
            const totalTimeSpan = document.createElement('span');
            totalTimeSpan.className = 'total-time';
            totalTimeSpan.textContent = formatDuration(entry.duration);

            // Create input field for description
            const descriptionInput = document.createElement('input');
            descriptionInput.type = 'text';
            descriptionInput.className = 'description-input';
            descriptionInput.value = entry.description || '';
            descriptionInput.placeholder = 'Enter task description';

            // Append all elements
            listItem.appendChild(document.createTextNode('Start: '));
            startDropdowns.forEach(dropdown => listItem.appendChild(dropdown));
            listItem.appendChild(document.createTextNode(' End: '));
            endDropdowns.forEach(dropdown => listItem.appendChild(dropdown));
            listItem.appendChild(document.createTextNode(' Total: '));
            listItem.appendChild(totalTimeSpan);
            listItem.appendChild(descriptionInput);

            // Create the remove button with trash can emoji
            const removeButton = document.createElement('button');
            removeButton.textContent = 'üóëÔ∏è';
            removeButton.className = 'remove-time-entry-button';
            removeButton.title = 'Delete entry';
            removeButton.addEventListener('click', (event) => {
            event.stopPropagation();
                removeTimeEntry(entry.id);
            });

            listItem.appendChild(removeButton);
            timeEntryListElement.appendChild(listItem);

            // Add event listeners to dropdowns and description input
            [...startDropdowns, ...endDropdowns].forEach(dropdown => {
                dropdown.addEventListener('change', () => updateTimeEntry(entry.id, listItem));
            });

            descriptionInput.addEventListener('input', () => updateTimeEntryDescription(entry.id, descriptionInput.value));
        });
    
        // Scroll to the bottom of the list
        scrollToBottom(timeEntryListElement);
    }

    function scrollToBottom(element) {
        element.scrollTop = element.scrollHeight;
    }
    
    function createDateTimeDropdowns(date, prefix) {
        const year = createDropdown(range(2020, 2030), date.getFullYear(), `${prefix}-year`);
        const month = createDropdown(range(1, 13), date.getMonth() + 1, `${prefix}-month`);
        const day = createDropdown(range(1, 32), date.getDate(), `${prefix}-day`);
        const hour = createDropdown(range(0, 24), date.getHours(), `${prefix}-hour`);
        const minute = createDropdown(range(0, 60), date.getMinutes(), `${prefix}-minute`);

        return [year, month, day, hour, minute];
    }

    function createDropdown(options, selectedValue, name) {
        const select = document.createElement('select');
        select.name = name;
        options.forEach(option => {
            const optionElement = document.createElement('option');
            optionElement.value = option;
            optionElement.textContent = option.toString().padStart(2, '0');
            if (option === selectedValue) optionElement.selected = true;
            select.appendChild(optionElement);
        });
        return select;
    }

    function range(start, end) {
        return Array.from({length: end - start}, (_, i) => start + i);
    }

    function updateTimeEntry(id, listItem) {
        const startDate = getDateFromDropdowns(listItem, 'start');
        const endDate = getDateFromDropdowns(listItem, 'end');
        const duration = endDate - startDate;

        // Update total time display
        const totalTimeSpan = listItem.querySelector('.total-time');
        totalTimeSpan.textContent = formatDuration(duration);

        // Update database
        dbReady.then(() => {
            let transaction = db.transaction(['timeEntries'], 'readwrite');
            let store = transaction.objectStore('timeEntries');
            let request = store.get(id);

            request.onsuccess = function(event) {
                let entry = event.target.result;
                entry.start = startDate.toISOString();
                entry.end = endDate.toISOString();
                entry.duration = duration;

                store.put(entry).onsuccess = function() {
                    console.log('Time entry updated successfully');
                };
            };
        });
    }

    function updateTimeEntryDescription(id, description) {
        dbReady.then(() => {
            let transaction = db.transaction(['timeEntries'], 'readwrite');
            let store = transaction.objectStore('timeEntries');
            let request = store.get(id);

            request.onsuccess = function(event) {
                let entry = event.target.result;
                entry.description = description;

                store.put(entry).onsuccess = function() {
                    console.log('Time entry description updated successfully');
                };
            };
        }).catch(error => {
            console.error('Database error:', error);
        });
    }

    function getDateFromDropdowns(listItem, prefix) {
        const year = listItem.querySelector(`[name="${prefix}-year"]`).value;
        const month = listItem.querySelector(`[name="${prefix}-month"]`).value - 1;
        const day = listItem.querySelector(`[name="${prefix}-day"]`).value;
        const hour = listItem.querySelector(`[name="${prefix}-hour"]`).value;
        const minute = listItem.querySelector(`[name="${prefix}-minute"]`).value;

        return new Date(year, month, day, hour, minute);
    }

    function saveTimeEntry(startTime, endTime) {
        dbReady.then(() => {
            if (currentProject) {
                let transaction = db.transaction(['timeEntries'], 'readwrite');
                let store = transaction.objectStore('timeEntries');

                let entry = {
                    projectId: currentProject.id,
                    start: new Date(startTime).toISOString(),
                    end: new Date(endTime).toISOString(),
                    duration: endTime - startTime,
                    description: ''
                };

                console.log('Saving time entry:',entry);
                console.log('Start:', new Date(startTime));
                console.log('End:', new Date(endTime));
                console.log('Duration:', formatDuration(entry.duration));
                console.log('Elapsed time (ms):', entry.duration);

                let request = store.add(entry);

                request.onsuccess = function() {
                    console.log('Time entry saved successfully');
                    loadTimeEntries(); // Refresh time entries for the current project
                };

                request.onerror = function(event) {
                    console.error('Error saving time entry:', event);
                };
            } else {
                console.error('No project selected.');
                alert('Please select a project first.');
            }
        }).catch(error => {
            console.error('Database error:', error);
        });
    }

    function removeTimeEntry(id) {
        dbReady.then(() => {
            let transaction = db.transaction(['timeEntries'], 'readwrite');
            let store = transaction.objectStore('timeEntries');
            let request = store.delete(id);

            request.onsuccess = function() {
                console.log('Time entry removed');
                loadTimeEntries(); // Reload the time entries after removal
            };

            request.onerror = function(event) {
                console.error('Error removing time entry:', event);
            };
        }).catch(error => {
            console.error('Database error:', error);
        });
    }

    function addManualEntry() {
        if (!currentProject) {
            alert('Please select a project first.');
            return;
        }

        const now = new Date();
        const entry = {
            projectId: currentProject.id,
            start: now.toISOString(),
            end: now.toISOString(),
            duration: 0,
            description: ''
        };

        console.log('Adding manual entry:', entry);

        dbReady.then(() => {
            let transaction = db.transaction(['timeEntries'], 'readwrite');
            let store = transaction.objectStore('timeEntries');

            let request = store.add(entry);

            request.onsuccess = function(event) {
                console.log('Manual time entry added successfully');
                loadTimeEntries();
                // Scroll to bottom after adding a manual entry
                scrollToBottom(document.getElementById('timeEntryList'));
            };

            request.onerror = function(event) {
                console.error('Error adding manual time entry:', event);
            };
        }).catch(error => {
            console.error('Database error:', error);
        });
    }

    </script>
</body>
</html>

